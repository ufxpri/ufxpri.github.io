다음 형태의 프로그래밍 방식은 무엇이 될까 비쥬얼 프로그래밍? 마법진? 어쩌면 우리는 마법진을 만들고있는것은 아닐까? 프로그래밍 언어는 필요에 의해 저수준에서 고수준으로 계속 발전해왔다. 그것의 최소 형태는 0과1이고 그것의 최종 형태는 영어이다. 언어는 1차원 정보로서 무수한 차원을 설명할 수 있는 아주 강ㅇ력한 도구였다. 우리는 이를 이용해 프로그래밍을 할 생각을 하였고 기계는 이러한 고차원 정보를 해석할 수 있는 더 복잡한 존재로 발전해왔다. 우리는 지금 기계어를 쓰는 과거를 이해할 수 없는 위치에 서있으며 그와 동시에 우리가 쓰는 언어 이하의 형태로 미시세계를 건설하고 있다. 지금은 그 과도기에 있기에 우리의 언어가 곧 기존의 시스템을 엎을것이라는 생각은 하지 못하고 있다. 이를 보완하기 위해 우리는 다양한 전략들을 세우고 패턴을 만들고 재사용하고 최적화하며 원하는 형태를 만들었고 그것이 지금의 형태이다. 우리는 이러한 과도기에서 다음단계로 넘어가기 위한 중간 단계가 필요하다. 어떠한 존재를 구현화할때 그것을 구현하기 위한 추상적인 존재. 이것을 이해할 수 있어야한다. 우리는 이런 추상적인 존재의 활용을 증명하면서 다음 스텝에 대한 가능성을 보여주어야 한다. "빛이 있으리" 이것이 곧 프로그램을 시작하는 첫 문장이 될 것이고 그 뒤의 내용들은 세부 사항을 구현하기 위한 단계가 될 것이다. 우리가 겪고있는 문제는 빛이 있다고 해서 무언가 만들어지지 않는다는 것이다. 그것은 아직 ai 의 능력 부족 한계가 될 것이다. 그렇기때문에 우리는 그것이 이미 존재한다고 가정하고 접근해야한다. 빛이 있는순간 무언가 존재한다. 하지만 동작하진 않는다. 거기에 우리는 몇가지를 더 추가한다. 이들은 서로 유기적으로 동작한다. 기존의 프로그래밍은 요구사항들을 스텝을 모두 손으로 엮어가며 작업했지만 새로운 프로그래밍 형태는 이런 구조에 엮여서는 안된다. 하나하나의 선언이 유기적으로 엮이는것을 가정으로 한다. 이들은 하나 하나 선언을 추가하여 구체화 되어간다. 구체화는 지속적이여야 한다. 그렇지 않은 단계의 텍스트는 그저 아무말이나 지껄이는 환상가의 혼잣말일 뿐이다. 우리 가 이해하는 동작의 단위까지 내려가야 한다. 예를들어 물리도 우리가 아는 수준에서 동작한다. 물건을 던지면 물건이 날아간다. 그러나 날아가면서 중력의 영향을 받거나 바람의 저항을 받는등의 동작은 더 미세 수준에서 동작한다 하지만 이러한 정보 없이도 물건을 날리는게 목적이였다면 목적을 이룬것이 된다. 이것이 우리가 이해하는 수준이며 새로운 형태의 프로그래밍 또한 이러한 형태이다. 우리가 이해하는 수준의 동작이란 기존 하드웨어에 구현된 드라이버 수준의 명령어 그것의 사용방법 전략 상태관리 패턴 이것들이 된다. 그 이하 수준의 작업은 이미 기존 프로그래머 들이 이미 만들어두었다. 그러나 한번에 그 수준까지 가는것도 아직은 먼 길이다. 이를 구현하기 위한 길잡이로써 처음에는 클래스 다이어그램을 생각했다. 그다음은 비쥬얼 프로그래밍을 생각했다. 그 다음은 무엇일까? 우리가 지속적으로 질문을 던질 수 있는 형태이고 그리고 그것을 구체화 해갈 수 있는 원리. 추상적인 존재를 어떻게 표현할까? 기존의 패턴은 어떻게 활용되는걸까? 이것이 인간이 생각해야할 내용인가? 한번 시험해 볼까? 가정의 시작 나는 삶의 불편함을 해결하려한다. 문제가 있을지다. 옷을 입는게 힘들다. 힘들다면 무엇이? 옷을 사는게 힘들다, 입는게 힘들다, 빠는게 힘들다. 어떻게 해결해야할까? 아니 더 문제가 뭘까? 입는건 옷에대한 지식이 없어서이다. 그럼 지식을 전달하면 되겠네 어떻게? 다양한 전략이 있다. 사람의 본성을 찾아서 그들의 마음에 드는 옷을 찾아야 한다. 그들은 어떤옷을 좋아할까? 자신을 반영하는 패턴에 맞는 옷스타일 그러면 그들의 정보를 알아야겠네 알면 어떻게 할건데 전달하는건 어떻게 할건데 할건데 할건데 이렇게 퍼져간다. 최초의 형태가 없는 추상화된 무언가에서 데이터가 팔을 뻩는 느낌. 그것이 기획에서 프로그램으로 전환되는 순간. 형태는 프로그램의 수준으로 가서는 안된다. 추상의 수준에서 모두 끝나야 한다. 추상의 수준이 모두 구현 가능한 단계에 도달했을때 한번에 시스템이 완성된다. 물론 단위를 나누어 개발하는 것도 존재하지만 이 전략은 오히려 지금의 상태를 엮어버리는 결과에 도달한다. 액체에서 결정이 생기기 전 불순물이 생기면 전체의 패턴이 무너지듯 우리는 중간에 무엇을 구현해서는 안된다. 재사용도 일리는 있지만 재사용성은 결국 완성된 형태 에서의 결과 이니라. DDD 패턴은 결국 미래를 예측하고 구체화 하는 과정이라 생각할 수 있다. 그냥 구체화하고 구현하면 되는데 그치? 개념은 서로 엮인다. 그리고 어떠한 소프트웨어의 형태로 구현된다. 그것이 어떤레벨일까 어떻게 상호작용할까? 이것은 어떤 수준에서의 구현인가에 따라 달라지지 않을까 한다. 예를들어 바구니를 만들어줘 수준에서 바구니를 그냥 주면 된다. 그러나 좀더 멋진 바구니를 만들어줘 하면 바구니를 분해한 단계의 재료를 소집하여 구체화 해야한다. 이 형태에 따라 추상화의 수준이 달라지고 요구되는 스킬이 달라진다. 우리는 이러한 형태의 소프트웨어적 특성 떄문에 다음과 같은 형태를 기획해야 한다. 내가 원하는 소프트웨어를 구현하는것은 세무 명세를 구체화 하는 과정에 완성된다. 기존의 것을 활용하여 구현할 수 있기 전 단계에서는 구현의 디테일을 요구로 한다. 우리는 디테일을 추가할 수록 소프트웨어 형태에 점점 가까워진다. 디테일이 모두 추가되고 그 정의가 기존의 것을 활용하여 완성할 수 있는 단계가 되면 소프트웨어는 구현된다. 이를 이루기 위해서 지속적으로 질문을 던지는 무언가가 필요하다. 그리고 정보의 계층도, 관계도 철저히 관리해야한다. 어떤 기능이 어디에 엮여있는지 굉장히 중요한 단서가 된다. 우리는 무언가 수정이 필요하다고 생각할때 다른곳에 있는것을 잊고는 한다. 모든 선언문은 서로 엮여있어 관계를 찾을 수 있어야 한다. 이 선언문이 무언가를 수정하고자 할때 관련된 모든것을 불러와 수정한다. 프로그래밍은 무한 차원을 가지고 있다고 생각한다. 무한 차원을 표현하는 가장 효율적인 정보 체계가 무엇인가 하면 바로 벡터 아닌가 무한 백터가 되겠지만.. 무한으로 뻗어나갈 수 있는 그래프 형태도 매력적이나 하지만 그래프 형태는 그 확장의 잠재성을 묶어두기 때문에 백터가 우선은 현실적으로 보인다. 선언은 엮인다. 계층을 만들 수 있다. 우리의 뇌는 1차원이다. 1차원으로 다차원의 정보를 엮기위해선 정보를 1차원으로 정렬할 필요가 있다. 그것이 이 개발 방법론이 요구하는 구현. 선언문의 엮임이 1차원 정보가 되어 보여지고 이를 수정하고 반영할 수 있는것 그것이 새로운 소프트웨어 아니 설계 문서가 되지 않을까 한다. 인간이 만든 설계도는 굉장히 단순화되어있고 정형화되어있고 명확하다. 하지만 이렇게 만든 설계도는 매우 추상적일 것이다. 그러면 이 추상적인 정도를 어떻게 측정할까 어떻게 실제 구현과 연결할까? 할 수 있다와 할 수 없다는 어떻게 판단할까? 그 구현 지점의 요구를 모두 모았을때 그것을 만족하는 무언가가 있으면 그것은 구현가능, 반대로 그것을 만족하는 무언가가 없다면 이를 더 구체화 하는 단계가 필요하다. 아직 ai는 그정도 컨텍스트는 처리하지 못하니 현재의 ai가 처리 가능한 수준에서의 구현이라면 사용할 수 있는 툴 또는 전략 또는 모듈들을 이어주는 형태가 될 것이다. 기존의 라이브러리는 이와 어떻게 상호작용 하게 될까? 추상적인 구현의 레이어에 딱 들어맞는 무언가가 있다면 그것이 라이브러리가 될까? 라이브러리는 레이어 된 계층과 파편화된 계층이 있다고 생각하는데 파편화 된 무언가는 요구사항의 어떤 특수한 패턴을 만족하는 무언가가 있을때 이를 만족하는 특정 형태의 크리스탈이라 생각한다. 이렇게 굳어진 파트는 요구사항을 만족하지만 수정하려할때 깨진다. 따라서 요구사항이 겹치고 중첩되고 분리할 수 없을 때 사용할 수 없다. 이부분에서 엔지니어는 미세 가공을 수행했다. 그것을 지원하는 라이브러리도 있다. 크리스탈이 동적으로 형태가 변하는 무언가. 있다. 그렇다면 이는 어떤 패턴일까? 우리의 요구사항을 어떠한 차원 또는 그래프로 그려낸다. 그래프는 우리가 이해할 수 있는 수준의 차원으로 내려온다. 이를 꽉 잡고있는 라이브러리나 엔진 툴들이 마치 그 요구사항을 수정할 수 없도록 꽉 잡고있는 크리스탈의 형태로 나타난다. 이를 수정하고 싶으면 그 크리스탈을 관철하는 어떠한 개념(사용자 계정 정보라고 할 수도)이 그 내부에 통로를 만들고 있다면 그 크리스탈의 작은 구멍이 뚫린것이라 볼 수 있다. 이 공간을 통과할 수 있는 요구사항이라면 그 위에 구현될 수 있지만 그렇지 않다면 이를 깨부숴야 하는 상황이 생길 수 있다. 그러나 이부분은 너무 디테일하다. 사용자가 언어의 형태 이외에 이를 이해하는것이 어렵지 않을까 하는 생각이 든다. 그렇다면 기획을 크리스털 화 할 수도 있지 않을까? 처음 기획은 형태가 없는것에서 형태가 있는것으로 바꾸는것. 크리스탈화 하는 절차 정보를 풀어놓고 그것을 묶는 단계 그러니까 고체화가 가능한 수준으로 디테일하게 된다면 이를 고체화 할 수 있다. 이제 구체화 된 것 같다. 우리는 기획으로 시작해서 크리스털을 만드는 과정에 있다. 시작은 추상적인 무언가 무한한 공간의 한 점이다. 그 점을 우리는 디테일하게 넓혀간다. 요구사항은 서로 정보의 단위로 엮이고 관계가 형성되며 구체화 되간다. 우리는 다차원 정보를 소화하기 위해 1차원 화 할 수 있는 능력이 필요하다. 예를 들면 사용자-계정-물품-구매-카드사-결제 이런 연결이 다차원 연결중 한곳에 존재할 때 우리는 이런 경로를 찾아 문장화 할 수 있다. 그리고 이 연결들은 일렬적이지 않은 다른 무언가와 연결되어있을 가능성이 높다. 그렇기 때문에 다른 차원에서도 이 요구사항을 볼 수 있다. 물품-계정-사용자 이런 관계도 성립한다. 이러한 정보가 디테일화되고 어떤 요구사항에 패턴이 생기면 그 패턴을 만족하는 라이브러리를 사용할 수 있다. 아 어쩌면 라이브러리를 먼저 가져와서 구현을 시작할 수 도 있겠다. 이미 잘 동작하는 크리스털화 된 라이브러리를 가져와서 그 위에 결정을 얹어 추가하는것 처럼 동작할 수 있다. 스프링을 사용한다면 사용할 수 있는 객체들은 이미 크리스털이고 이들사이에 정보가 엮인다. 정보의 관계는 함수가 아닐까? 함수가 객체의 관계를 설명하는걸까? 그래프의 관계가 그것이 될 것이다. 양방향 그래프. 루프가 생겨도 될까? 루프는 안될까? 있어도 된다. 그러나 의도되었어야 한다. 이렇게 만들어진 소프트웨어는 마치 기존의 잘생긴 크리스털에 무언가 아직 구현되지 않은 물 같은것이 붙어있고 이를 디테일하게 만드는 단계가 소프트웨어를 정의하는 단계가 될것 같다. 코드로 구현한다. 이것은 결정화 한다. 이런것이다. 우리는 아직 2d 화면에 같혀있다. 이를 2 d 에 표현해야한다. 소프트웨어는 2d에서 다차원 정보를 표현할 수 있다. 그래프가 이를 가능하게 한다. 다른 차원으로 회전도 가능해야한다. 차원은 이를 가장 잘 대표하는 단위로 평면화 될 수 있어야 한다. 마치 이런식. 계정: 모든 시스템을 계정의 관점에서 본다. 계정이 있고 이 주변에 존재하는 기능들 정의 들이 존재한다. 인프라: 시스템이 구현되는 종속 지점에 따라 엮인다. 예를들어 a는 b시스템을 모니터링 한다 했을때 이는 시스템 관점에서 엮인다. 그이외에 다양한 관점에서 정렬이 가능하다. 우리는 이렇게 시스템을 다양한 차원에서 바라보며 아직 구현되지 않은 부분을 찾는다. 그곳에 요구사항을 끼워넣는다. 어떤 요구사항은 아직 안개 수준이다. 이는 코드화 될 필요가 있다. 크리스털 화 되어야 할 필요가 있다. 크리스털은 수정이 필요한 순간 깨지고 유연해진다. 연결된 모든것이 잘 깨진다. 그리고 그것을 구현할때 다시 딱딱히 굳는다. 프로그램을 3d 형태로 보여주는건 어떤가 아니다 이런걸 고민할 필요가 없어야한다. 원하는 차원을 만들수 있어야한다. 예를들어 시스템 차원을 만들수 있다. 사용자 차원을 만들 수 있다. 이러면 2차원이다. 모듈 차원을 만들 수 있다. 이러면 3차원이다. 더 많은 차원을 나타내는 것을 만들 수 있다. 이러면 4차원이다. 우리는 3차원 회전까지를 머리에 담을 수 있기에 이정도만 추천하지만 필요하다면 만들 수 있다. 차원을 정의하는 프롬프트를 목록의 형태로 만들 수 있다. 좌측 바에 차원을 추가하는 리스트를 넣는다. 원하는 수 많큼 추가할 수 있다. 탐색은 정보간 이동으로 한다. 어떤 정보에 다가가면 그 주변의 정보를 좌측 차원리스트에 의해 배치한다. 메인 디스플에이에는 정보들이 그래프 노드로 표현되어 있다. 이들은 최초에는 아무것도 없다가 사용자가 프롬프트를 치는 순간 발생한다. 이 노드들은 크리스탈 상태와 액채 상태로 존재한다. (기체 상태도 있으려나~) 프롬프트를 입력할 때 마다 액체를 추가한다. 액체화 된것들은 기존의 요소들 중 그들을 크리스털 화 할 만한 게 있으면 크리스털 화 시킬 수 있다고 알려준다 그걸 크리스털 화 하면 코드가 된다. 기존 요소는 마치 촉진재 같은 것들이다. 디자인 패턴, 라이브러리, 프레임워크 들이 이에 해당한다. 그러나 다양한 차원에서 이를 촉진 할 수 있다고 하는것들이 많으니 이에 대한 주의가 필요하다. 하단에는 프롬프트 입력창이 있다. 프롬프트는 소프으웨어를 정의하는 문자열을 입력으로 받는다. 문자열이 입력되면 노드가 발생한다. 노드는 모든 노드와 관계를 유지한다. (연결 강도로?) 노드 하나는 정보 하나를 의미한다(어쩌면 기본 데이터 형태? 자료형?) 이들은 양방향 관계를 가진다. (함수? 기능? 그러니까 사용자는 물건을 구매한다?) 이들이 최초에 구현될때 기획이 완벽하지 않다면 끝나지 않은 문장들이 생기거나 (1차원으로 완성이 안되는 문장이 생김) 그냥 공중에 둥 떠있다.(아무것과 상호작용 하지 않는 상태) 우리는 이를 이어주기 위한 프롬프트를 계속 입력한다. 그러면 객체간에 연관이 생기고 이어진다. 이어진 강도가 결정의 형태일까? 각 노드는 결정화 될 수 있는 확률을 보여준다. 100%가 되어야 결정화가 된다. 100이면 결정화 버튼을 누를 수 있다. 결정은 노드 단위가 아니다 정보의 집합의 단위이다. 노드의 집합의 단위이다. 노드집합이 결정화 되면 그 구간은 크리스털화 되어 표현된다. 영역이 굳어진다. 모든 차원에서 굳어지기 때문에 차원을 변경할 때 마다 형태는 다르게 보일 수 있다. 그러나 다른 것들과 상호작용할때 수정하기 힘들다. 그리고 크리스털화는 곧 코드가 됨을 의미한다. 이수준에서 코드를 직접 볼 수 있다. 크리스털 화는 그 개념의 범위가 정해져 있다. 그 개념의 내부에 하위 개념이 있는데 이게 아직 자유료울 수 있다는 것이다. 기존의 프로그래밍 방식도 사용할 수 있어야 한다. 파일 트리 를 예로 들자면 이 다차원 공간을 파일 이라는 차원으로 정렬하면 그것이 곧바로 파일트리가 되는 구조이다. 설계자는 파일을 먼저 만들고 파일에 관련된 기능을 정의 할 수 있는 것이다. 